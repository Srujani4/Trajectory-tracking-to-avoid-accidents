# -*- coding: utf-8 -*-
"""Untitled26.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tm5ffdSgQ073pLd5JcF3QG-WTEwneZjq
"""

import torch
import torch.nn as nn
import torch.optim as optim
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import imageio

# Dataset loading function for RNN
def load_dataset(file_path, seq_length):
    df = pd.read_csv(file_path)
    features_list = []
    targets_list = []

    for case_id, case_group in df.groupby("case_id"):
        agent_data = case_group[["x", "y", "vx", "vy", "psi_rad"]].values
        target_data = case_group["track_to_predict"].values

        for i in range(len(agent_data) - seq_length):
            features_list.append(agent_data[i : i + seq_length])
            targets_list.append(target_data[i + seq_length - 1])

    features = np.array(features_list)
    targets = np.array(targets_list)
    return features, targets

class RNNModel(nn.Module):
    def __init__(self, input_size, hidden_size, num_layers, output_size):
        super(RNNModel, self).__init__()
        self.num_layers = num_layers
        self.hidden_size = hidden_size
        self.rnn = nn.RNN(input_size, hidden_size, num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_size, output_size)

    def forward(self, x):
        h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(x.device)
        out, _ = self.rnn(x, h0)
        out = self.fc(out[:, -1, :])
        return out

# Model and training parameters
input_size = 5  # Number of features per timestep (x, y, vx, vy, psi_rad)
hidden_size = 64
num_layers = 1
output_size = 1  # Predicting track_to_predict column (0 or 1)
learning_rate = 0.0001
epochs = 1000
seq_length = 5  # Length of the input sequence for RNN
l2_lambda = 0.001

# Load dataset and split into train, validation, and test sets
X, y = load_dataset("/content/DR_LaneChange_ET0_obs.csv", seq_length)
X = torch.tensor(X, dtype=torch.float32)
y = torch.tensor(y, dtype=torch.float32)

X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42)
X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42)

model = RNNModel(input_size, hidden_size, num_layers, output_size)

criterion = nn.BCEWithLogitsLoss()  # Binary Cross Entropy with Logits (for binary classification)
optimizer = optim.Adam(model.parameters(), lr=learning_rate, weight_decay=l2_lambda)

train_losses = []
val_losses = []

for epoch in range(epochs):
    model.train()
    outputs = model(X_train)
    loss = criterion(outputs.squeeze(), y_train)
    train_losses.append(loss.item())

    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    if (epoch + 1) % 100 == 0:
        print(f'Epoch [{epoch+1}/{epochs}], Train Loss: {loss.item():.4f}')

    with torch.no_grad():
        model.eval()
        val_outputs = model(X_val)
        val_loss = criterion(val_outputs.squeeze(), y_val)
        val_losses.append(val_loss.item())

        print(f'Epoch [{epoch+1}/{epochs}], Val Loss: {val_loss.item():.4f}')

# Save the trained model
torch.save(model.state_dict(), 'trained_model.pth')

# Plot the training and validation loss graphs
plt.figure()
plt.plot(train_losses, label='Train Loss')
plt.plot(val_losses, label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.title('Training and Validation Loss')
plt.savefig('loss_graph.png')
plt.close()

# Test the model using the testing data
model.eval()
with torch.no_grad():
    test_outputs = model(X_test)
    test_loss = criterion(test_outputs.squeeze(), y_test)
    print(f'Test Loss: {test_loss.item():.4f}')

# Generate a gif output
model.eval()
predictions = []
with torch.no_grad():
    for x in X_test:
        output = model(x.unsqueeze(0))
        predictions.append(output.round().item())

images = []
for i in range(len(X_test)):
    plt.figure()
    plt.scatter(X_test[i][:, 0], X_test[i][:, 1], c='b', label='History')
    plt.scatter(X_test[i][-1, 0], X_test[i][-1, 1], c='r', label='Current')
    plt.title(f'Prediction: {predictions[i]}')
    plt.legend()
    plt.xlabel('x')
    plt.ylabel('y')
    plt.xlim(X_test[i][:, 0].min() - 10, X_test[i][:, 0].max() + 10)
    plt.ylim(X_test[i][:, 1].min() - 10, X_test[i][:, 1].max() + 10)
    plt.savefig(f'output_frame_{i}.png')
    plt.close()

    images.append(imageio.imread(f'output_frame_{i}.png'))

imageio.mimsave('output.gif', images)